Число **e** відіграє важливу роль при аналізі ефективності алгоритмів, особливо коли йдеться про експоненціальне зростання або зменшення в часі або в обсягах даних. Його використання є фундаментальним для багатьох алгоритмів, які стосуються пошуку, оптимізації та керування складністю.

#### 2.1 **Алгоритми з експоненціальною складністю**

В алгоритмічній теорії часто використовують експоненціальні алгоритми, де час виконання зростає експоненціально залежно від розміру вхідних даних. Такі алгоритми зазвичай мають вигляд:

T(n)=O(2n)абоT(n)=O(en),T(n) = O(2^n) \quad \text{або} \quad T(n) = O(e^n),T(n)=O(2n)абоT(n)=O(en),

де nnn — розмір вхідних даних, а T(n)T(n)T(n) — час виконання алгоритму. Це означає, що навіть незначне збільшення вхідних даних призводить до значного збільшення часу виконання.

**Приклад**: Одним з прикладів є задача **пошуку підмножин** (subset-sum problem), яка є NP-повною. Для даного набору чисел потрібно знайти підмножину, сума елементів якої дорівнює заданому значенню. Класичний алгоритм вирішення цієї задачі має експоненціальну складність, оскільки перевіряються всі можливі комбінації елементів.

Якщо в наборі є 20 чисел, кількість можливих підмножин дорівнює 220=1,048,5762^{20} = 1,048,576220=1,048,576. Якщо додати лише 10 додаткових чисел, кількість комбінацій зросте до 230=1,073,741,8242^{30} = 1,073,741,824230=1,073,741,824, що значно збільшить час виконання.

#### 2.2 **Балансовані дерева та пошукові алгоритми**

У структурах даних, таких як **двійкові дерева пошуку** (binary search trees) або **AVL-дерева**, логарифмічна складність операцій (додавання, пошук, видалення) базується на властивостях числа **e** через натуральний логарифм log⁡e\log_eloge​ (або ln⁡\lnln). У збалансованих деревах висота дерева зростає логарифмічно відносно кількості елементів, що дозволяє забезпечити ефективний пошук і вставку за час O(log⁡n)O(\log n)O(logn).

- **Логарифмічна складність** означає, що при подвоєнні кількості елементів у дереві, час для операцій зростає не лінійно, а лише на незначну кількість кроків (залежно від логарифму основи **e**).

**Приклад**: Якщо у вас є збалансоване двійкове дерево з 1 мільйоном елементів, середній час пошуку елемента дорівнюватиме приблизно log⁡2(106)≈20\log_2(10^6) \approx 20log2​(106)≈20 операцій. Якщо кількість елементів зросте до 1 мільярда, кількість операцій для пошуку збільшиться лише до log⁡2(109)≈30\log_2(10^9) \approx 30log2​(109)≈30, що значно краще, ніж лінійний ріст.

#### 2.3 **Ймовірнісні алгоритми**

Ймовірнісні алгоритми використовують випадкові числа для вирішення завдань, і багато з них пов'язані з експоненціальним розподілом або натуральними логарифмами для визначення очікуваного часу або кількості ітерацій.

Одним із прикладів є **алгоритм Монте-Карло**, який використовує випадкові вибірки для розв’язання задач, наприклад, для оцінки інтегралів або пошуку наближених рішень оптимізаційних задач.

**Приклад**: Алгоритм швидкого сортування (QuickSort) використовує розподіл опорних елементів для розбиття масиву. Якщо обраний елемент випадковий, то середня складність сортування дорівнює O(nlog⁡n)O(n \log n)O(nlogn). Тут log⁡n\log nlogn базується на натуральному логарифмі, оскільки кількість кроків, потрібних для поділу масиву на дві частини, є логарифмічною. Однак у найгіршому випадку, коли опорний елемент обирається не оптимально (наприклад, коли масив уже відсортований), складність може стати O(n2)O(n^2)O(n2), що є експоненціальною залежністю.

#### 2.4 **Аналіз експоненціальних алгоритмів у практиці**

Незважаючи на те, що експоненціальні алгоритми мають високу складність, вони все ще використовуються у практиці, особливо в умовах обмежених обчислювальних ресурсів або коли потрібні точні результати.

**Приклад**: У шифруванні, зокрема у RSA-алгоритмі, під час генерації ключів використовується експоненціальна складність для забезпечення криптографічної стійкості. Функція y=exy = e^xy=ex, де xxx — велике число, використовується для шифрування повідомлень. Число **e** тут допомагає у створенні великих просторових значень для генерації ключів. Розв’язання рівняння такого типу без знання секретного ключа потребує експоненційного часу.

#### 2.5 **Швидкі алгоритми зі складністю O(log⁡n)O(\log n)O(logn)**

У багатьох випадках алгоритми з експоненціальною складністю можна замінити на логарифмічні або поліноміальні підходи, якщо застосувати оптимізаційні методи або розподіл даних.

- **Алгоритм двійкового пошуку** використовує логарифмічну складність O(log⁡n)O(\log n)O(logn), де nnn — кількість елементів у відсортованому масиві. Кожен крок двійкового пошуку поділяє масив на дві частини, що зменшує кількість можливих варіантів вдвічі.

**Приклад**: Для пошуку числа в масиві з 1 мільйоном елементів за допомогою двійкового пошуку потрібно приблизно log⁡2(106)≈20\log_2(10^6) \approx 20log2​(106)≈20 операцій. Це надзвичайно ефективно порівняно з лінійним пошуком, який потребував би до 1 мільйона операцій у найгіршому випадку.